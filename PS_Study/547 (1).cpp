/*
Prob No.547 : Robo-K [CH04.1.Competition(IamCoder#7)]

Time Limit(Test case) : 1000(ms)
Total Submit : 37    Accepted : 16
Background

GSHS의 보드게임 동아리 메인보드에서는 로보k라는 게임을 많이 한다. 로보k의 규칙은 다음과 같다. 

자기 차례가 되면 카드를 한 장 뒤집는다. 
현재까지의 뒤집힌 카드의 합이 11의 배수이거나 k 이상이면 마지막으로 카드를 뒤집은 사람이 지게 된다. 

또한 특수한 카드 두 종류가 있는데 x2는 다음에 뒤집힐 카드의 수를 두 배 해서 더한다. x2 카드가 여러 장 연속해서 나올 경우 다음에 나오는 카드에 곱해지는 수도 x2, x4, x8...이 된다. 

리버스 카드는 순서를 반대로 돌아가게 한다. 


1번부터 시작하여 사람 수가 증가하는 순서로 차례가 돌아가며, 
마지막 사람 이후에는 다시 1번 사람의 차례가 된다. 


현재 카드 더미에 쌓여있는 카드가 위에서부터 순서대로 주어질 때, 
지게 되는 사람의 번호를 구하여라.
Input

첫 번째 줄에 사람의 수 n(2<=n<=1,000,000), 카드의 수 m(1<=m<=50,000,000)와 k(1<=k<=100,000,000)가 주어진다. 
두 번째 줄에 카드에 쓰여져 있는 공백으로 구분된 m개의 숫자가 주어진다. 

카드에 쓰여 있는 수의 범위는 -10,000 이상 10,000 이하이며, 
10,001은 리버스 카드를, 10,002는 x2 카드를 의미한다.
Output

첫 줄에 지게 되는 사람의 번호를 출력한다. 
카드를 모두 뒤집었는데 지는 사람이 결정되지 않았다면 0을 출력하라.
IO Example

입력1 
5 11 100 
2 5 10002 1 10001 10002 10002 3 2 10 10001 

출력1 
5 


입력2 
2 1 7 
0 

출력2 
1 


입력3 
3 2 9 
1 7 

출력3 
0 

* 1번 예제에 대한 설명 

2 - 1번이 2를 뒤집음, 카드 합 2 

5 - 2번이 5를 뒤집음, 카드 합 7 

10002 - 3번이 x2를 뒤집음, 카드 합 7 

1 - 4번이 1을 뒤집음, 카드 합 9(7+1*2) 

10001 - 5번이 리버스를 뒤집음 

10002 - 4번이 x2를 뒤집음 

10002 - 3번이 x2를 뒤집음 

3 - 2번이 3을 뒤집음, 카드 합 21(9+3*2*2) 

2 - 1번이 2를 뒤집음, 카드 합 23 

10 - 5번이 10을 뒤집음, 카드 합 33 



카드 합이 33이므로 5번의 패배 

출제 - 배예찬 (GSHS 30rd) 
*/
#include<cstdio>
long long n,m,k,f=1,s,t,i,p,c;
long long fun(int n){
	long long t=1;
	for(;n--;)t*=2;
	return t;
}
int main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	for(i=0;i<m ; i++){
		scanf("%lld",&t);
		p=(p+f)%n;
		if(p<=0) p=n;
		if(t==10002){ ++c; continue;}
		if(t==10001){ f=-1*f; continue;}		
		c=fun(c);
		s+=t*c;
		c=0;
		if( s%11==0 || s>=k ) break;
	}
	if(i==m) printf("0");
	else printf("%lld",p);   
}
